pub struct Position {
  line: u32,
  column: u32,
}

pub struct Span {
  start: Position,
  end: Position,
}

pub struct Symbol {
  span: Span,
  view: []u8,
}

pub struct Int {
  span: Span,
  view: []u8,
}

pub struct Float {
  span: Span,
  view: []u8,
}

pub enum OperatorKind {
  sub,
}

pub struct Operator {
  span: Span,
  kind: OperatorKind,
}

pub struct EndOfFile {
  span: Span,
}

pub enum Token {
  symbol: Symbol,
  int: Int,
  float: Float,
  operator: Operator,
  end_of_file: EndOfFile,
}

pub struct Cursor {
  position: Position,
  input: []u8,
}

pub fn next_token(cursor: Cursor) -> (Cursor, Token) {
  cursor = trim_whitespace(cursor)
  if cursor.input.len == 0 {
    return end_of_file_token(cursor)
  }
  match cursor.input[0] {
    'a' ..= 'z' | 'A' ..= 'Z' | '_' => symbol_token(cursor),
    '0' ..= '9' => number_token(cursor),
    '-' => operator_token(cursor, OperatorKind::sub),
    _ => assert(false, "TODO: this should return an error token")
  }
}

fn take_while_stateful[T](
  cursor: Cursor,
  predicate: fn(u8, *T) -> bool,
  state: *T
) -> (Cursor, []u8) {
  i = 0
  for c in input {
    if not predicate(c, state) {
      break
    }
    i += 1
  }
  (.{ cursor.position + i, cursor.input[i..] }, cursor.input[..i])
}

fn matches_predicate(c: u8, predicate: fn(u8) -> bool) -> bool {
  predicate(c)
}

fn take_while(cursor: Cursor, predicate: fn(u8) -> bool) -> (Cursor, []u8) {
  take_while_stateful(cursor, matches_predicate, predicate)
}

fn is_space(c: u8) -> bool {
  c == ' '
}


fn trim_whitespace(cursor: Cursor) -> Cursor {
  (cursor, _) = take_while(cursor, is_space)
  cursor
}

fn is_valid_for_symbol(c: u8) -> bool {
  match c {
    'a'..='z' | 'A'..='Z' | '0'..='9' | '_' => true,
    _ => false,
  }
}

fn symbol_token(cursor: Cursor) -> (Cursor, Token) {
  (cursor, symbol) = take_while(cursor, is_valid_for_symbol)
  (cursor, .{
    symbol: .{
      span: .{
        start: cursor.position,
        end: cursor.position + symbol.len,
      },
      view: symbol
    }
  })
}

fn is_number(c: u8, decimals: *u8) -> bool {
  match c {
    '0'..='9' => true,
    '.' => {
      *decimals = 1
      true
    }
    _ => false,
  }
}

fn number_token(cursor: Cursor) -> (Cursor, Token) {
  decimals = 0
  (cursor, number) = take_while_stateful(cursor, is_number, &decimals)
  token = match decimals {
    0 => .{ int: .{
      span: .{
        start: cursor.position,
        end: cursor.position + number.len,
      },
      view: number
    }}
    1 => .{
      float: .{
        span: .{
          start: cursor.position,
          end: cursor.position + number.len,
        },
        view: number
      }
    }
    _ => assert(false, "TODO: this should return an error token")
  }
  (cursor, token)
}

fn operator_token(cursor: Cursor, kind: OperatorKind) -> (Cursor, Token) {
  start = cursor.position
  cursor = .{
    input: cursor.input[1..],
    position = .{
      line: cursor.position.line,
      column: cursor.position.column + 1
    }
  }
  (cursor, .{
    operator: .{
      span: .{
        start,
        end: cursor.position,
      },
      kind: kind
    }
  })
}

fn end_of_file_token(cursor: Cursor) -> (Cursor, Token) {
  (cursor, .{
    end_of_file: .{
      span: .{
        start: cursor.position,
        end: cursor.position
      }
    }
  })
}
