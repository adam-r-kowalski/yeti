pub struct Position:
    line: u32
    column: u32


pub struct Span:
    start: Position
    end: Position


pub struct Symbol:
    span: Span
    view: []u8


pub struct Int:
    span: Span
    view: []u8


pub struct Float:
    span: Span
    view: []u8


pub enum OperatorKind:
    sub


pub struct Operator:
    span: Span
    kind: OperatorKind


pub struct EndOfFile:
    span: Span


pub enum Token:
    symbol: Symbol
    int: Int
    float: Float
    operator: Operator
    end_of_file: EndOfFile


pub struct Cursor:
    position: Position
    input: []u8


pub fn next_token(cursor: Cursor) -> (Cursor, Token):
    cursor = trim_whitespace(cursor)
    if cursor.input.len == 0:
        return end_of_file_token(cursor)
    match cursor.input[0]:
        case 'a' ..= 'z' | 'A' ..= 'Z' | '_':
           symbol_token(cursor),
        case '0' ..= '9':
            number_token(cursor),
        case '-':
            operator_token(cursor, OperatorKind::sub),
        case _:
            assert(false, "TODO: this should return an error token")


fn take_while_stateful[T](
  cursor: Cursor,
  predicate: fn(u8, T) -> (bool, T),
  state: T
) -> (Cursor, []u8):
    i := 0
    for c in input:
        if not predicate(c, state):
            break
        i += 1
    position = Position(
      line: cursor.position.line,
      column: cursor.position.column + i
    )
    (Cursor(cursor.input[i..], position }, cursor.input[..i])


fn matches_predicate(c: u8, predicate: fn(u8) -> bool) -> bool:
    predicate(c)


fn take_while(cursor: Cursor, predicate: fn(u8) -> bool) -> (Cursor, []u8):
    (cursor, value, _) = take_while_stateful(cursor, matches_predicate, predicate)
    (cursor, value)



