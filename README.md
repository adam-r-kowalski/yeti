# The Yeti Programming Language

![Yeti logo](logo.webp)

## Introduction

Yeti is born from the need to write software that's as close to the metal as possible while maintaining portability across a diverse range of devices and hardware architectures. In a landscape dominated by high-level languages that often abstract away the underlying hardware, Yeti seeks to provide a path for developers to express their code with precision and intentionality, directly reflecting the algorithms' structure onto the hardware for optimal performance.

## The Yeti Philosophy

### Directness Over Abstraction

Yeti challenges the trend of increasing abstraction in software development. While abstraction can sometimes simplify complexity, it often does so at the cost of obscuring the underlying mechanisms that are crucial for performance. Yeti encourages a style where abstraction is employed not to hide, but to clarify—enabling developers to articulate their intentions directly to the hardware, be it CPU, GPU, or any other processing unit.

### Custom Memory Management

Rejecting the notion of a one-size-fits-all solution like garbage collection, Yeti advocates for tailored memory management. Developers can choose the most appropriate allocator for their needs—arena, pool, or stack allocators, among others. This approach allows for more predictable performance, especially critical in real-time or resource-constrained environments.

### Development and Deployment Flexibility

Yeti recognizes the varied devices developers use for writing code, from high-end workstations to tablets and emerging devices like the Vision Pro. The language and its tooling are designed to ensure that developers can work effectively on their platform of choice, with a seamless experience from development to deployment. Yeti's goal is to reduce reliance on server-based compilation or execution, favoring local processing to minimize latency and maintain functionality regardless of network connectivity.

## Exploring Yeti's Potential

Yeti is an exploration into whether a language can offer the directness and control typically associated with low-level programming without sacrificing the portability and convenience that modern developers need. It's an invitation to rethink how we engage with our tools and platforms, aiming to make the act of programming a more intentional and informed practice.

## Joining the Journey

Yeti is in its early stages, and we're not looking to build an ecosystem just yet. Instead, we're focused on validating the core principles and understanding the potential benefits and challenges of this approach. We welcome feedback, insights, and contributions from those who share an interest in shaping the future of software development with clarity, efficiency, and purpose.

---

This revision aims to present Yeti in a straightforward manner, focusing on its core principles and design goals. It avoids grandiose claims, instead inviting the reader to explore the potential of the language with an open and critical mindset. Does this version better align with your vision for Yeti?
